import { Router } from "express";
import { rpcCall } from "../rpc";
import * as fs from "fs";
import { DEFAULTS, DATA_DIR, CONF_FILE, parseConfFile } from "../lib/config";


export const settingsRouter = Router();

// Keys that should NOT be written to the config file (managed elsewhere)
const SKIP_CONF_KEYS = new Set(["addnode"]);

// Convert settings object to prometheus.conf format
function toConfFile(settings: Record<string, unknown>): string {
  const lines: string[] = [
    "# BTC-Prometheus configuration",
    "# Generated by Sovereign Controls UI",
    "",
  ];

  for (const [key, value] of Object.entries(settings)) {
    if (SKIP_CONF_KEYS.has(key)) continue;
    if (value === "" || value === undefined || value === null) continue;

    if (Array.isArray(value)) {
      // Repeated keys (onlynet, debug)
      for (const item of value) {
        lines.push(`${key}=${item}`);
      }
    } else if (typeof value === "boolean") {
      lines.push(`${key}=${value ? "1" : "0"}`);
    } else {
      lines.push(`${key}=${value}`);
    }
  }

  // Write addnode entries separately
  const addnodes = settings.addnode as string[] | undefined;
  if (addnodes && addnodes.length > 0) {
    lines.push("");
    for (const addr of addnodes) {
      lines.push(`addnode=${addr}`);
    }
  }

  lines.push("");
  return lines.join("\n");
}

// GET current policy settings
settingsRouter.get("/", async (_req, res) => {
  try {
    const policy = (await rpcCall("getpolicy")) as Record<string, unknown>;

    // Read saved settings from config file (includes dbcache, addnode, etc.)
    const confSettings = parseConfFile();

    // Read addnode from RPC (runtime-added nodes not yet in config)
    let rpcAddnodes: string[] = [];
    try {
      const added = (await rpcCall("getaddednodeinfo")) as Array<{
        addednode: string;
      }>;
      rpcAddnodes = added.map((n) => n.addednode);
    } catch { }

    // Merge addnode from config + RPC
    const confAddnodes = Array.isArray(confSettings.addnode) ? confSettings.addnode as string[] : [];
    const allAddnodes = [...new Set([...confAddnodes, ...rpcAddnodes])];

    // Layer: defaults < config file < RPC policy (most authoritative)
    res.json({ ...DEFAULTS, ...confSettings, ...policy, addnode: allAddnodes });
  } catch (err: unknown) {
    res.json(DEFAULTS);
  }
});

// POST save settings
settingsRouter.post("/", async (req, res) => {
  const settings = req.body as Record<string, unknown>;
  const applied: string[] = [];
  const errors: string[] = [];
  let configWritten = false;

  // 1. Apply runtime changes via RPC (addnode)
  const addnodes = settings.addnode as string[] | undefined;

  // Remove stale addnodes that the user deleted from the list
  try {
    const current = (await rpcCall("getaddednodeinfo")) as Array<{
      addednode: string;
    }>;
    const newSet = new Set(addnodes || []);
    for (const node of current) {
      if (!newSet.has(node.addednode)) {
        try {
          await rpcCall("addnode", [node.addednode, "remove"]);
          applied.push(`removed addnode ${node.addednode}`);
        } catch { }
      }
    }
  } catch { }

  // Add new addnodes
  if (addnodes && addnodes.length > 0) {
    for (const addr of addnodes) {
      try {
        await rpcCall("addnode", [addr, "add"]);
        applied.push(`addnode ${addr}`);
      } catch (err: unknown) {
        // "already added" is not an error
        const msg = err instanceof Error ? err.message : String(err);
        if (msg.includes("already added") || msg.includes("already connected")) {
          applied.push(`addnode ${addr} (already connected)`);
        } else {
          errors.push(`addnode ${addr}: ${msg}`);
        }
      }
    }
  }

  // 2. Write config file for settings that need restart
  try {
    const confContent = toConfFile(settings);
    fs.mkdirSync(DATA_DIR, { recursive: true });
    fs.writeFileSync(CONF_FILE, confContent, "utf8");
    configWritten = true;
    applied.push("prometheus.conf written");
  } catch (err: unknown) {
    const msg = err instanceof Error ? err.message : String(err);
    errors.push(`Config write failed: ${msg}`);
  }

  res.json({
    ok: errors.length === 0,
    applied,
    config_written: configWritten,
    errors,
  });
});
